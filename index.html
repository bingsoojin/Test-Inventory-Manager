<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Inventory Manager</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #fff; color: #000; }
        h1 { font-size: 32px; font-weight: bold; color: #000; text-align: center; margin-bottom: 20px; }
        .dark-mode h1 { color: #f4f4f4; }
        input, select, button { margin: 5px; padding: 8px; width: 300px; }
        label { display: inline-block; width: 150px; font-weight: bold; }
        .form-line { display: flex; align-items: center; margin-bottom: 10px; }
        .error-msg { color: red; font-size: 12px; margin-left: 10px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; table-layout: fixed; }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;      /* keep everything one line by default */
        }
        /* Cells that are allowed to wrap when text is long */
        td.wrap-cell {
            white-space: normal;
            word-wrap: break-word;
        }
        th { background-color: #f4f4f4; }
        .dark-mode { background-color: #121212; color: #f4f4f4; }
        .dark-mode table th { background-color: #333; }
        .top-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .left-controls { display: flex; gap: 10px; }
        .right-controls { display: flex; gap: 10px; align-items: center; }
        .icon-btn { background-color: #eee; color: #000; border: 1px solid #ccc; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; font-size: 18px; cursor: pointer; }
        .dark-mode .icon-btn { background-color: #444; color: #fff; border: 1px solid #888; }

        /* Column widths (10 columns total: SKU, Name, Desc, Ref, Prod, Qty, Expiry, Type, Status, Actions) */
        th:nth-child(2), td:nth-child(2) { width: 19%; }  /* Name */
        th:nth-child(3), td:nth-child(3) { width: 23.5%; }  /* Description */
        th:nth-child(4), td:nth-child(4) { width: 12%; }  /* Reference */
        th:nth-child(5), td:nth-child(5) { width: 16%; }  /* Producer */
        th:nth-child(6), td:nth-child(6) { width: 3%; }   /* Qty */
        th:nth-child(7), td:nth-child(7) { width: 7.5%; }  /* Expiry */
        th:nth-child(8), td:nth-child(8) { width: 10%; }  /* Type */
        th:nth-child(9), td:nth-child(9) { width: 5%; }  /* Status */
        th:nth-child(10), td:nth-child(10) { width: 6%; } /* Actions */

        button.small-btn {
            padding: 6px 12px;    /*button size */
            font-size: 12px;      /*button font size */
            width: 90px;          /*button width size */
        }
    </style>
</head>
<body>
    <h1>Inventory Management</h1>
    <div class="top-bar">
        <div class="left-controls">
            <input type="text" id="skuInput" placeholder="Scan or Enter SKU" autofocus>
            <button onclick="checkSKU()">Check</button>
        </div>
        <div class="right-controls">
            <button onclick="exportExcel()">Export Excel</button>
            <button onclick="exportJSON()">Export JSON</button>
            <input type="file" id="importFile" style="display:none" accept=".json,.xlsx" onchange="importFile(event)">
            <button onclick="document.getElementById('importFile').click()">Import from file</button>
            <!-- NEW: Settings button -->
            <button onclick="openSettings()">Settings</button>
            <button class="icon-btn" onclick="toggleDarkMode()" title="Toggle Dark Mode">☀/☾</button>
        </div>
    </div>

    <div id="formContainer" style="margin-top:20px;"></div>

    <table id="inventoryTable">
        <thead>
            <tr>
                <th>SKU</th>
                <th>Name</th>
                <th>Description</th>
                <th>Reference</th>
                <th>Producer</th>
                <th>Qty</th>
                <th>Expiry</th>
                <th>Type</th>
                <th>Status</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    <script>
        let inventory = JSON.parse(localStorage.getItem('inventory') || '[]');
        let editIndex = null;

        /* ==== NEW: dynamic consumable types (settings-driven) ==== */
        const defaultConsumableTypes = [
            'Tubing',
            'Dressing',
            'Sample vial',
            'Metals',
            'Syringe',
            'Needle',
            'Other'
        ];

        let consumableTypes = (function () {
            try {
                const saved = JSON.parse(localStorage.getItem('consumableTypes') || 'null');
                if (Array.isArray(saved) && saved.length > 0) return saved;
            } catch {}
            return [...defaultConsumableTypes];
        })();

        function saveConsumableTypes() {
            localStorage.setItem('consumableTypes', JSON.stringify(consumableTypes));
        }

        function getTypeOptionsHTML(selectedValue) {
            let html = '<option value="Select">Select</option>';
            consumableTypes.forEach(t => {
                const sel = t === selectedValue ? ' selected' : '';
                html += `<option${sel}>${t}</option>`;
            });
            return html;
        }
        /* ========================================================= */

        // Theme initialisation: default to dark but respect saved choice
        (function initTheme() {
            const saved = localStorage.getItem('theme');
            if (saved === 'light') {
                document.body.classList.remove('dark-mode');
            } else {
                // default dark mode
                document.body.classList.add('dark-mode');
                localStorage.setItem('theme', 'dark');
            }
        })();

        function saveInventory() {
            localStorage.setItem('inventory', JSON.stringify(inventory));
            renderTable();
        }

        function renderTable() {
            const tbody = document.querySelector('#inventoryTable tbody');
            tbody.innerHTML = '';
            const sortedInventory = [...inventory].reverse();
            sortedInventory.forEach((item) => {
                const idx = inventory.indexOf(item);
                const row = `<tr>
                    <td>${item.sku || ''}</td>
                    <td class="wrap-target">${item.name || ''}</td>
                    <td class="wrap-target">${item.description || ''}</td>
                    <td class="wrap-target">${item.reference || ''}</td>
                    <td class="wrap-target">${item.producer || ''}</td>
                    <td>${item.qty != null ? item.qty : ''}</td>
                    <td>${item.expiry || ''}</td>
                    <td>${item.type || ''}</td>
                    <td>${item.status || ''}</td>
                    <td><button class="small-btn" onclick="editProduct(${idx})">Edit</button></td>
                </tr>`;
                tbody.innerHTML += row;
            });
        
            applyConditionalWrapping();
        }

        // Only wrap text in cells that are actually long, keep everything else single-line.
        function applyConditionalWrapping() {
            const cells = document.querySelectorAll('#inventoryTable td.wrap-target');
        
            cells.forEach(cell => {
                const text = (cell.textContent || '').trim();
        
                // Threshold: tweak this number if you want more or less wrapping
                if (text.length > 30) {
                    cell.classList.add('wrap-cell');
                } else {
                    cell.classList.remove('wrap-cell');
                }
            });
        }
        
        function formatExpiry(input) {
            let val = input.value.replace(/[^0-9]/g, '');
            if (val.length === 8) {
                input.value = val.slice(0,4) + '/' + val.slice(4,6) + '/' + val.slice(6);
            }
        }

        // Expiry validation: YYYY/MM/DD between 2000/01/01 and 2100/01/01, or 0000/00/00
        function isValidExpiry(val) {
            val = val.trim();
            if (val === '0000/00/00') return true;

            const m = /^(\d{4})\/(\d{2})\/(\d{2})$/.exec(val);
            if (!m) return false;

            const year = parseInt(m[1], 10);
            const month = parseInt(m[2], 10);
            const day = parseInt(m[3], 10);

            const date = new Date(year, month - 1, day);
            if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) return false;

            const min = new Date(2000, 0, 1);   // 2000-01-01
            const max = new Date(2100, 0, 1);   // 2100-01-01
            if (date < min || date > max) return false;

            return true;
        }

        function validateAndSubmit(type) {
            const form = document.getElementById(type === 'add' ? 'addForm' : 'editForm');
            let valid = true;

            form.querySelectorAll('input, select').forEach(field => {
                const value = field.value.trim();

                if (field.name === 'expiry') {
                    if (!isValidExpiry(value)) {
                        field.style.border = '2px solid red';
                        valid = false;
                    } else {
                        field.style.border = '';
                    }
                } else {
                    if (!value || value === 'Select') {
                        field.style.border = '2px solid red';
                        valid = false;
                    } else {
                        field.style.border = '';
                    }
                }
            });

            if (valid) {
                if (type === 'add') {
                    addProduct();
                } else {
                    saveEdit(editIndex);
                }
            }
        }

        // Focus first "open" field: empty or 'Select', and not readonly.
        function focusFirstOpenField(formId) {
            const form = document.getElementById(formId);
            if (!form) return;
            const fields = form.querySelectorAll('input, select, textarea');

            // First pass: empty / Select fields
            for (const field of fields) {
                if (field.readOnly) continue;
                const val = (field.value || '').trim();
                if (!val || val === 'Select') {
                    field.focus();
                    return;
                }
            }
            // Fallback: first editable field
            for (const field of fields) {
                if (!field.readOnly) {
                    field.focus();
                    return;
                }
            }
        }

        // If SKU exists: "Add Another Item" (prefill, new expiry/qty).
        // If SKU doesn't exist: standard Add New Product.
        function checkSKU() {
            const skuInput = document.getElementById('skuInput');
            const sku = skuInput.value.trim();
            if (!sku) return;

            const existing = inventory.find(item => item.sku === sku);
            const container = document.getElementById('formContainer');

            if (existing) {
                container.innerHTML = `<h3>Add Another Item</h3>
                    <form id="addForm">
                        <div class="form-line"><label>SKU:</label><input name="sku" value="${existing.sku}" readonly></div>
                        <div class="form-line"><label>Name:</label><input name="name" value="${existing.name || ''}" required></div>
                        <div class="form-line"><label>Description:</label><input name="description" value="${existing.description || ''}" required></div>
                        <div class="form-line"><label>Reference:</label><input name="reference" value="${existing.reference || ''}" required></div>
                        <div class="form-line"><label>Producer:</label><input name="producer" value="${existing.producer || ''}" required></div>
                        <div class="form-line"><label>Quantity:</label><input name="qty" type="number" min="1" value="${existing.qty != null ? existing.qty : 1}" required></div>
                        <div class="form-line"><label>Expiry:</label><input name="expiry" placeholder="YYYY/MM/DD or 0000/00/00" onblur="formatExpiry(this)" required></div>
                        <div class="form-line"><label>Type of consumable:</label>
                            <select name="type" required>
                                ${getTypeOptionsHTML(existing.type)}
                            </select>
                        </div>
                        <div class="form-line"><label>Status:</label>
                            <select name="status" required>
                                <option value="Select">Select</option>
                                <option ${existing.status === 'Sealed' ? 'selected' : ''}>Sealed</option>
                                <option ${existing.status === 'Unsealed' ? 'selected' : ''}>Unsealed</option>
                                <option ${existing.status === 'N/A' ? 'selected' : ''}>N/A</option>
                                <option ${existing.status === 'Damaged' ? 'selected' : ''}>Damaged</option>
                            </select>
                        </div>
                        <button type="button" onclick="validateAndSubmit('add')">Add Item</button>
                        <button type="button" onclick="cancelEdit()">Cancel</button>
                    </form>`;

                attachEnterListeners('add');
                focusFirstOpenField('addForm');

            } else {
                container.innerHTML = `<h3>Add New Product</h3>
                    <form id="addForm">
                        <div class="form-line"><label>SKU:</label><input name="sku" value="${sku}" readonly></div>
                        <div class="form-line"><label>Name:</label><input name="name" required></div>
                        <div class="form-line"><label>Description:</label><input name="description" required></div>
                        <div class="form-line"><label>Reference:</label><input name="reference" required></div>
                        <div class="form-line"><label>Producer:</label><input name="producer" required></div>
                        <div class="form-line"><label>Quantity:</label><input name="qty" type="number" min="1" value="1" required></div>
                        <div class="form-line"><label>Expiry:</label><input name="expiry" placeholder="YYYY/MM/DD or 0000/00/00" onblur="formatExpiry(this)" required></div>
                        <div class="form-line"><label>Type of consumable:</label>
                            <select name="type" required>
                                ${getTypeOptionsHTML('')}
                            </select>
                        </div>
                        <div class="form-line"><label>Status:</label>
                            <select name="status" required>
                                <option value="Select">Select</option>
                                <option value="Sealed">Sealed</option>
                                <option value="Unsealed">Unsealed</option>
                                <option value="N/A">N/A</option>
                                <option value="Damaged">Damaged</option>
                            </select>
                        </div>
                        <button type="button" onclick="validateAndSubmit('add')">Add Product</button>
                        <button type="button" onclick="cancelEdit()">Cancel</button>
                    </form>`;
                attachEnterListeners('add');
                focusFirstOpenField('addForm');
            }

            skuInput.value = '';
        }

        function attachEnterListeners(type) {
            const form = document.getElementById(type === 'add' ? 'addForm' : 'editForm');
            if (!form) return;
            const fields = Array.from(form.querySelectorAll('input, select'));
            fields.forEach((field, idx) => {
                field.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        if (idx < fields.length - 1) {
                            fields[idx + 1].focus();
                        } else {
                            validateAndSubmit(type);
                        }
                    }
                });
            });
        }
        
        // Find an existing item where ALL fields (except qty) match
        function findMatchingItemIndex(data) {
            const norm = v => (v ?? '').toString().trim();
        
            return inventory.findIndex(item =>
                norm(item.sku)         === norm(data.sku) &&
                norm(item.name)        === norm(data.name) &&
                norm(item.description) === norm(data.description) &&
                norm(item.reference)   === norm(data.reference) &&
                norm(item.producer)    === norm(data.producer) &&
                norm(item.expiry)      === norm(data.expiry) &&
                norm(item.type)        === norm(data.type) &&
                norm(item.status)      === norm(data.status)
            );
        }

        function cancelEdit() {
            const container = document.getElementById('formContainer');
            if (container) {
                container.innerHTML = '';
            }
            const skuInput = document.getElementById('skuInput');
            if (skuInput) {
                skuInput.focus();
            }
        }

        function addProduct() {
            const form = document.getElementById('addForm');
            const data = Object.fromEntries(new FormData(form).entries());
        
            // Normalise qty from form
            data.qty = parseInt(data.qty, 10);
            if (isNaN(data.qty) || data.qty < 0) data.qty = 0;
        
            // Check if a fully matching item already exists
            const matchIndex = findMatchingItemIndex(data);
        
            if (matchIndex !== -1) {
                // Merge: increase qty on existing line
                const existingQty = parseInt(inventory[matchIndex].qty, 10) || 0;
                inventory[matchIndex].qty = existingQty + data.qty;
            } else {
                // No match: add as a new line
                inventory.push(data);
            }
        
            saveInventory();
            cancelEdit();
        }

        // Edit from table row – for changing product/item details
        function editProduct(index) {
            const item = inventory[index];
            if (!item) return;
            const container = document.getElementById('formContainer');
            container.innerHTML = `<h3>Edit Item</h3>
                <form id="editForm">
                    <div class="form-line"><label>SKU:</label><input name="sku" value="${item.sku || ''}" readonly></div>
                    <div class="form-line"><label>Name:</label><input name="name" value="${item.name || ''}" required></div>
                    <div class="form-line"><label>Description:</label><input name="description" value="${item.description || ''}" required></div>
                    <div class="form-line"><label>Reference:</label><input name="reference" value="${item.reference || ''}" required></div>
                    <div class="form-line"><label>Producer:</label><input name="producer" value="${item.producer || ''}" required></div>
                    <div class="form-line"><label>Quantity:</label><input name="qty" type="number" min="1" value="${item.qty != null ? item.qty : 1}" required></div>
                    <div class="form-line"><label>Expiry:</label><input name="expiry" value="${item.expiry || ''}" placeholder="YYYY/MM/DD or 0000/00/00" onblur="formatExpiry(this)" required></div>
                    <div class="form-line"><label>Type of consumable:</label>
                        <select name="type" required>
                            ${getTypeOptionsHTML(item.type)}
                        </select>
                    </div>
                    <div class="form-line"><label>Status:</label>
                        <select name="status" required>
                            <option value="Select">Select</option>
                            <option ${item.status === 'Sealed' ? 'selected' : ''}>Sealed</option>
                            <option ${item.status === 'Unsealed' ? 'selected' : ''}>Unsealed</option>
                            <option ${item.status === 'N/A' ? 'selected' : ''}>N/A</option>
                            <option ${item.status === 'Damaged' ? 'selected' : ''}>Damaged</option>
                        </select>
                    </div>
                    <button type="button" onclick="validateAndSubmit('edit')">Save Changes</button>
                    <button type="button" onclick="deleteItem(${index})">Delete</button>
                    <button type="button" onclick="cancelEdit()">Cancel</button>
                </form>`;
            editIndex = index;
            attachEnterListeners('edit');
            focusFirstOpenField('editForm');
        }

        function saveEdit(index) {
            const form = document.getElementById('editForm');
            const data = Object.fromEntries(new FormData(form).entries());
            data.qty = parseInt(data.qty, 10);
            if (isNaN(data.qty) || data.qty < 0) data.qty = 0;
            inventory[index] = data;
            saveInventory();
            cancelEdit();
        }

        function deleteItem(index) {
            const item = inventory[index];
            if (!item) return;
            const confirmed = window.confirm(`Delete item with SKU ${item.sku || ''}?`);
            if (confirmed) {
                inventory.splice(index, 1);
                saveInventory();
                cancelEdit();
            }
        }

        function exportExcel() {
            const ws = XLSX.utils.json_to_sheet(inventory);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Inventory');
            XLSX.writeFile(wb, 'inventory_export.xlsx');
        }

        function exportJSON() {
            const blob = new Blob([JSON.stringify(inventory)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'inventory_backup.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();

            if (file.name.endsWith('.json')) {
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (Array.isArray(data)) {
                            inventory = data;
                            saveInventory();
                        } else {
                            alert('Invalid JSON format');
                        }
                    } catch {
                        alert('Error reading JSON file');
                    }
                };
                reader.readAsText(file);
            } else if (file.name.endsWith('.xlsx')) {
                reader.onload = function(e) {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const sheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(sheet);
                    inventory = jsonData;
                    saveInventory();
                };
                reader.readAsArrayBuffer(file);
            }
        }

        function toggleDarkMode() {
            const isDark = document.body.classList.toggle('dark-mode');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
        }

        /* ===== SETTINGS PANEL: manage consumable types ===== */

        function openSettings() {
            const container = document.getElementById('formContainer');
            container.innerHTML = `
                <h3>Settings – Consumable Types</h3>
                <p>These values populate the "Type of consumable" dropdown.</p>
                <div id="typesList"></div>
                <div class="form-line">
                    <label>New type:</label>
                    <input id="newTypeInput" placeholder="e.g. Catheter">
                    <button type="button" onclick="addType()">Add</button>
                </div>
                <button type="button" onclick="closeSettings()">Close</button>
            `;
            renderTypesList();
        }

        function closeSettings() {
            document.getElementById('formContainer').innerHTML = '';
            document.getElementById('skuInput').focus();
        }

        function renderTypesList() {
            const listDiv = document.getElementById('typesList');
            if (!listDiv) return;
            let html = '<ul style="list-style:none;padding:0;margin:0;">';
            consumableTypes.forEach((t, idx) => {
                html += `
                    <li style="margin-bottom:6px; display:flex; align-items:center; gap:6px;">
                        <span style="flex:1;">${t}</span>
                        <button type="button" class="small-btn" onclick="editType(${idx})">Edit</button>
                        <button type="button" class="small-btn" onclick="deleteType(${idx})">Delete</button>
                    </li>
                `;
            });
            html += '</ul>';
            listDiv.innerHTML = html;
        }

        function addType() {
            const input = document.getElementById('newTypeInput');
            if (!input) return;
            const val = input.value.trim();
            if (!val) return;
            if (consumableTypes.includes(val)) {
                alert('Type already exists.');
                return;
            }
            consumableTypes.push(val);
            saveConsumableTypes();
            renderTypesList();
            input.value = '';
        }

        function editType(index) {
            const oldName = consumableTypes[index];
            const newName = window.prompt('Edit type name:', oldName);
            if (newName === null) return;
            const trimmed = newName.trim();
            if (!trimmed) return;
            if (consumableTypes.includes(trimmed) && trimmed !== oldName) {
                alert('Another type with this name already exists.');
                return;
            }
            consumableTypes[index] = trimmed;

            // Optional global rename: update existing inventory entries using this type
            inventory.forEach(item => {
                if (item.type === oldName) {
                    item.type = trimmed;
                }
            });

            saveConsumableTypes();
            saveInventory();
            renderTypesList();
        }

        function deleteType(index) {
            const name = consumableTypes[index];
            const confirmed = window.confirm(`Remove type "${name}" from the list? Existing items that already use it will keep their current value.`);
            if (!confirmed) return;
            consumableTypes.splice(index, 1);
            saveConsumableTypes();
            renderTypesList();
        }

        /* ==================================================== */

        document.getElementById('skuInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                checkSKU();
            }
        });

        renderTable();
    </script>
</body>
</html>
